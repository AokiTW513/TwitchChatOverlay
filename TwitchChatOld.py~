import queue
import tkinter.font as tkFont
import tkinter as tk
import websocket
import time
import datetime
import csv
from config import *
import threading
import keyboard

class PopupManager:
    def __init__(self):
        self.root = tk.Tk()
        self.root.withdraw()  # éš±è—ä¸»è¦–çª—

        self.queue = queue.Queue()
        self.popup = None
        self.font = tkFont.Font(family="Arial", size=18)

        self.bot = None

        self.check_queue()

        self.setup_hotkey()

    def set_bot(self, bot):
        self.bot = bot

    def check_queue(self):
        try:
            while True:
                user, message = self.queue.get_nowait()
                self.show_popup(user, message)
        except queue.Empty:
            pass
        self.root.after(100, self.check_queue)

    # é¡¯ç¤ºè¦–çª—
    def show_popup(self, user, message, duration=5000):
        text = f"{user}: {message}"

        if self.popup is not None and self.popup.winfo_exists():
            label = self.popup.label
            label.config(text=text, wraplength=600)
            self.resize_popup(text)
            self.popup.after_cancel(self.popup.after_id)
            self.popup.after_id = self.popup.after(duration, self.popup.destroy)
        else:
            self.popup = tk.Toplevel(self.root)
            self.popup.overrideredirect(True)
            self.popup.attributes("-topmost", True)
            self.popup.configure(
                bg="#1e1e1e",
                highlightbackground="#ffffff",  # é‚Šæ¡†é¡è‰²
                highlightthickness=3           # é‚Šæ¡†å¯¬åº¦ï¼ˆåƒç´ ï¼‰
            )

            self.popup.label = tk.Label(self.popup,
                                        text=text,
                                        font=self.font,
                                        fg="#00aaff",
                                        bg="#1e1e1e",
                                        anchor="w",
                                        justify="left",
                                        wraplength=600)
            self.popup.label.pack(fill="both", padx=10, pady=10)

            self.resize_popup(text)

            x, y = 20, 40

            self.popup.geometry(f"{self.width}x{self.height}+{x}+{y}")

            self.popup.after_id = self.popup.after(duration, self.popup.destroy)

    # æ›´æ–°è¦–çª—å¤§å°
    def resize_popup(self, text):
        paddingX = 30
        paddingY = 20
        min_width = 0    # æœ€å°å¯¬åº¦
        max_width = 600    # æœ€å¤§å¯¬åº¦

        # å…ˆç”¨å­—é«”é‡æ¸¬æ–‡å­—å¯¬åº¦ï¼ˆå¤§æ¦‚ï¼‰
        text_width_px = self.font.measure(text)

        # è¨­å®šå¯¬åº¦é™åˆ¶ï¼Œå¯¬åº¦ç‚ºæ–‡å­—å¯¬åº¦ + padding
        width = text_width_px + paddingX

        # é™åˆ¶å¯¬åº¦å€é–“
        if width < min_width:
            width = min_width
        elif width > max_width:
            width = max_width

        # è¨­å®š Label çš„ wraplength ç‚ºè¦–çª—å¯¬åº¦æ¸›å» padding
        wraplength = width - paddingX

        self.popup.label.config(text=text, wraplength=wraplength)
        self.popup.label.update_idletasks()

        req_height = self.popup.label.winfo_reqheight()
        height = req_height + paddingY

        self.width = width
        self.height = height

        self.popup.geometry(f"{self.width}x{self.height}+20+40")

    # å¿«é€Ÿéµé–‹å•Ÿå›è¦†èŠå¤©å®¤ç”¨çš„è¦–çª—
    def setup_hotkey(self):
    # ä½¿ç”¨ keyboard å…¨å±€ç›£è½ç†±éµï¼ˆé Tkinter ç¶å®šï¼‰
        keyboard.add_hotkey('ctrl+shift+t', lambda: self.root.after(0, self.open_reply_window))

    # é–‹å•Ÿå›è¦†èŠå¤©å®¤ç”¨çš„è¦–çª—
    def open_reply_window(self, event=None):
        if not hasattr(self, "reply_window") or not self.reply_window.winfo_exists():
            self.reply_window = tk.Toplevel(self.root)
            self.reply_window.title("")  # ä¸é¡¯ç¤ºæ¨™é¡Œæ–‡å­—
            self.reply_window.configure(bg="black")  # èƒŒæ™¯è‰²å¯æ”¹æˆç™½è‰²
            self.reply_window.overrideredirect(True)

            width, height = 400, 60

            # è¨ˆç®—è¢å¹•ä¸­å¤®ä½ç½®
            screen_width = self.reply_window.winfo_screenwidth()
            screen_height = self.reply_window.winfo_screenheight()
            x = (screen_width // 2) - (width // 2)
            y = (screen_height // 2) - (height // 2)
    
            self.reply_window.geometry(f"{width}x{height}+{x}+{y}")
    
            self.reply_entry = tk.Entry(
                self.reply_window,
                width=50,
                bg="black",        # èƒŒæ™¯è‰²
                fg="#00aaff",        # æ–‡å­—é¡è‰²
                insertbackground="white",  # æ¸¸æ¨™é¡è‰²
                relief="flat",     # å»æ‰é‚Šæ¡†
                borderwidth=0,       # ç„¡é‚Šæ¡†
                highlightthickness=0,# ç„¡é«˜äº®é‚Š
                font=("Arial", 14) # å¯é¸çš„å­—é«”è¨­å®š
            )
            self.reply_entry.pack(padx=10, pady=20)

            # é€™æ®µä¸»è¦æ˜¯æ‹¿ä¾†è®“æˆ‘æŠŠå®ƒå«å‡ºä¾†å¾Œå¯ä»¥è‡ªå‹•é¸å®šä»–ï¼Œä¸ç„¶åŸæœ¬å¥¹é‚„éœ€è¦é»ä¸€ä¸‹
            self.reply_window.lift()
            self.reply_window.attributes("-topmost", True)
            self.reply_window.after_idle(self.reply_window.attributes, '-topmost', False)
            self.reply_window.after(100, lambda: (self.reply_entry.focus_force(), self.reply_entry.focus_set()))

            # æŒ‰ä¸‹Enterè§¸ç™¼é€å‡º
            self.reply_window.bind("<Return>", lambda e: self.send_reply())
            # æŒ‰ESCé€€å‡º
            self.reply_window.bind("<Escape>", lambda e: self.reply_window.destroy())

    # å‚³å‡ºå›è¦†
    def send_reply(self):
        message = self.reply_entry.get().strip()
        if message:
            # å‡è¨­æœ‰wsç‰©ä»¶å¯ä»¥æ‹¿åˆ°
            global global_ws
            if global_ws:
                self.bot.send_message_to_chat(global_ws, message)
                print("å·²å‘èŠå¤©å®¤ç™¼é€è¨Šæ¯ï¼š", message)
                self.bot.show_popup("ç™¼é€", message)
            self.reply_window.destroy()

class TwitchBot:
    def __init__(self):
        #config.pyã‹ã‚‰è³‡æ–™å–ã‚Šã¾ã™
        self.access_token = f"oauth:{Access_Token}"  # oauth:access_token
        self.nickname = BOT_NICK
        self.channel = f"#{CHANNEL}"  # #å¿˜ã‚Œãªã„ã‚ˆã†ã«
        self.twitchWebsocketURL = TwitchWebsocketURL

        #ä»Šæ—¥ã®æ—¥ä»˜
        self.today = datetime.date.today().strftime('%Y%m%d')

        self.popup_manager = None
        self.responses = self.load_responses('responses.csv')
        
        self.isPopup = False
    
    def set_popup_manager(self, popup_manager):
        self.popup_manager = popup_manager

    def show_popup(self, user, message):
        self.popup_manager.queue.put((user, message))

    #csvã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’èª­ã¿è¾¼ã‚ã‚‹
    def load_responses(self, filename):
        self.responses = {}
        with open(filename, newline='', encoding='utf-8-sig') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                self.responses[row['trigger']] = row['response']
        return self.responses

    def check_and_reply(self, message):
        for trigger, reply in self.responses.items():
            if trigger in message:
                return reply
        return None

    #WebSocket æ¥ç¶šæˆåŠŸã—ãŸæ™‚
    def on_open(self, ws):
        global global_ws
        global_ws = ws
        print("æ¥ç¶šæˆåŠŸã€ãƒ­ã‚°ã‚¤ãƒ³ä¸­...")
        ws.send(f"PASS {self.access_token}")
        ws.send(f"NICK {self.nickname}")
        ws.send(f"JOIN {self.channel}")
        print(f"ãƒãƒ£ãƒƒãƒˆå…¥ã‚Šã¾ã—ãŸï¼ãƒãƒ£ãƒ³ãƒãƒ«ã¯{self.channel}ã§ã™ï¼")
        reply = "MrDestructoid ãƒãƒ£ãƒƒãƒˆå…¥ã‚Šã¾ã—ãŸï¼"
        self.send_message_to_chat(ws, reply)
        threading.Thread(target=self.break_reminder, args=(ws,), daemon=True).start()


    #WebSocket ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ã‘ãŸæ™‚
    def on_message(self, ws, message):
        #å¤šåˆ†Twitch APIã‹ã‚‰ãƒœãƒƒãƒˆã¾ã ç”Ÿãã¦ã‚‹ã‹ãƒ†ã‚¹ãƒˆã™ã‚‹ã®ã‚‚ã®
        if message.startswith("PING"):
            ws.send("PONG :tmi.twitch.tv")
            print("PONG")
            return

        #ãƒãƒ£ãƒƒãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        if "PRIVMSG" in message:
            #ãƒãƒ£ãƒƒãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åˆ†æã™ã‚‹ #å…ƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¤šåˆ†ã“ã‚“ãªæ„Ÿã˜ :aokitw513!aokitw513@aokitw513.tmi.twitch.tv PRIVMSG #aokitw513 :wow
            try:
                #ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’print
                user = message.split("!", 1)[0][1:] #[1:]ã¯ç¬¬ä¸€ã®æ–‡å­—ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã“ã¨ ex.hello[1:]=ello [0]ãªã‚‰åˆ†å‰²ã—ãŸã‚‚ã®ã®ç¬¬ä¸€éƒ¨åˆ†ã§ã™ã­
                content = message.split("PRIVMSG", 1)[1].split(":", 1)[1]
                print(f"{user}: {content.strip()}") #stripã¯stringã®å‰å¾Œã®\nã¨ã‹å‰Šé™¤ã™ã‚‹ã‚‚ã®

                if self.isPopup:
                    self.show_popup(user, content.strip())
            
                #ãƒãƒ£ãƒƒãƒˆãƒ­ã‚°
                with open(self.today + '_chat' + '.txt', 'a', encoding='utf-8-sig') as f :
                    localTime = time.localtime()
                    f.write(f"{time.strftime('%H:%M:%S --',localTime)} " + user + ': ' + content)

                #ã‚³ãƒãƒ³ãƒ‰
                """ if content.strip().startswith("å®‰å®‰"):
                    reply = f"{user} ãƒ‹ãƒ¼ãƒã‚ªï¼"
                    send_message_to_chat(ws, reply) """
                reply = self.check_and_reply(message)
                if reply:
                    self.send_message_to_chat(ws, f"@{user} {reply}")

                #ç‰¹æ®Šã‚³ãƒãƒ³ãƒ‰
                # if content.strip().startswith("æ—©å®‰"):
                #     now = datetime.datetime.now() #ä»Šã®æ™‚é–“
                #     hour = now.hour #ä»Šä½•æ™‚
                #     if 5 <= hour < 12:
                #         reply = f"@{user} æ—©å•Š aokitwGood"
                #         self.send_message_to_chat(ws, reply)
                #     else:
                #         reply = f"@{user} ä¸æ˜¯ï¼Œæ—©å€‹å±ï¼Œéƒ½{hour}é»äº† aokitwHatena"
                #         self.send_message_to_chat(ws, reply)

                #ãƒ†ã‚¹ãƒˆ
                if (content.strip().startswith("!ãƒ†ã‚¹ãƒˆ")  or content.strip().startswith("!test")) and user == CHANNEL:
                    reply = "ç„¡äº‹ã«å®Ÿè¡Œã•ã‚Œã¾ã—ãŸï¼"
                    self.send_message_to_chat(ws, reply)

                #!csvå…¥åŠ›ã™ã‚Œã°CSVãƒªã‚»ãƒƒãƒˆã§ãã‚‹
                if (content.strip().startswith("!csv") or content.strip().startswith("!CSV")) and user == CHANNEL:
                    self.responses = self.load_responses('responses.csv')
                    reply = "CSVãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸï¼"
                    self.send_message_to_chat(ws, reply)

                #ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆçµ‚äº†
                if content.strip().startswith("!çµ‚äº†") or content.strip().startswith("!close") and user == CHANNEL:
                    print("çµ‚äº†ã—ã¾ã™")
                    reply = "ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆçµ‚äº†ã—ã¾ã™"
                    self.send_message_to_chat(ws, reply)
                    ws.send(f"PART {self.channel}")
                    print("ãƒãƒ£ãƒƒãƒˆã‚’é›¢ã‚Œã¾ã—ãŸ")
                    ws.close()

            except Exception as e:
                print(f"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åˆ†æå¤±æ•—: {e}")

    #ãƒãƒ£ãƒƒãƒˆã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚·ã‚™é€ã‚‹
    def send_message_to_chat(self, ws, reply):
        ws.send(f"PRIVMSG {self.channel} :{reply}")
        
    def break_reminder(self, ws):
        while True:
            time.sleep(3600)  # ç­‰å¾… 1 å°æ™‚
            reply = "åª½çš„éƒ½æ‰“ä¸€å€‹å°æ™‚äº†é‚„æ‰“ ä¸å»è®€æ›¸>:("
            self.send_message_to_chat(ws, reply)
            print("ğŸ’¡ å·²ç™¼é€ä¼‘æ¯æé†’")

    #WebSocket ã‚¨ãƒ©ãƒ¼ã®æ™‚
    def on_error(ws, error):
        print(f"ã‚¨ãƒ©ãƒ¼: {error}")

    #WebSocket é–‰ã˜ã‚‹æ™‚
    def on_close(ws, close_status_code, close_msg):
        print("æ¥ç¶šçµ‚äº†")

    #WebSocket æ¥ç¶š
    def websocket_thread(self):
        self.twitchWS = websocket.WebSocketApp(
            self.twitchWebsocketURL,
            on_open = self.on_open,
            on_message = self.on_message,
            on_error = self.on_error,
            on_close = self.on_close
        )
        self.twitchWS.run_forever()

if __name__ == '__main__':
    bot = TwitchBot()
    popup_manager = PopupManager()

    # é¿å…å¾ªç’°
    bot.set_popup_manager(popup_manager)
    popup_manager.set_bot(bot)
    # ç”¨å­åŸ·è¡Œç·’è·‘ WebSocket
    threading.Thread(target=bot.websocket_thread, daemon=True).start()
    # ä¸»åŸ·è¡Œç·’è·‘ Tkinter mainloop
    popup_manager.root.mainloop()
